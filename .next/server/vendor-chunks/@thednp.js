"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@thednp";
exports.ids = ["vendor-chunks/@thednp"];
exports.modules = {

/***/ "(ssr)/./node_modules/@thednp/dommatrix/dist/dommatrix.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@thednp/dommatrix/dist/dommatrix.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ y)\n/* harmony export */ });\nvar Z = Object.defineProperty;\nvar z = (s, t, e) => t in s ? Z(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar p = (s, t, e) => z(s, typeof t != \"symbol\" ? t + \"\" : t, e);\nconst $ = {\n  a: 1,\n  b: 0,\n  c: 0,\n  d: 1,\n  e: 0,\n  f: 0,\n  m11: 1,\n  m12: 0,\n  m13: 0,\n  m14: 0,\n  m21: 0,\n  m22: 1,\n  m23: 0,\n  m24: 0,\n  m31: 0,\n  m32: 0,\n  m33: 1,\n  m34: 0,\n  m41: 0,\n  m42: 0,\n  m43: 0,\n  m44: 1,\n  is2D: !0,\n  isIdentity: !0\n}, E = (s) => (s instanceof Float64Array || s instanceof Float32Array || Array.isArray(s) && s.every((t) => typeof t == \"number\")) && [6, 16].some((t) => s.length === t), P = (s) => s instanceof DOMMatrix || s instanceof y || typeof s == \"object\" && Object.keys($).every((t) => s && t in s), g = (s) => {\n  const t = new y(), e = Array.from(s);\n  if (!E(e))\n    throw TypeError(\n      `CSSMatrix: \"${e.join(\",\")}\" must be an array with 6/16 numbers.`\n    );\n  // istanbul ignore else @preserve\n  if (e.length === 16) {\n    const [\n      n,\n      i,\n      r,\n      a,\n      l,\n      m,\n      h,\n      c,\n      u,\n      f,\n      w,\n      o,\n      d,\n      A,\n      M,\n      b\n    ] = e;\n    t.m11 = n, t.a = n, t.m21 = l, t.c = l, t.m31 = u, t.m41 = d, t.e = d, t.m12 = i, t.b = i, t.m22 = m, t.d = m, t.m32 = f, t.m42 = A, t.f = A, t.m13 = r, t.m23 = h, t.m33 = w, t.m43 = M, t.m14 = a, t.m24 = c, t.m34 = o, t.m44 = b;\n  } else if (e.length === 6) {\n    const [n, i, r, a, l, m] = e;\n    t.m11 = n, t.a = n, t.m12 = i, t.b = i, t.m21 = r, t.c = r, t.m22 = a, t.d = a, t.m41 = l, t.e = l, t.m42 = m, t.f = m;\n  }\n  return t;\n}, X = (s) => {\n  if (P(s))\n    return g([\n      s.m11,\n      s.m12,\n      s.m13,\n      s.m14,\n      s.m21,\n      s.m22,\n      s.m23,\n      s.m24,\n      s.m31,\n      s.m32,\n      s.m33,\n      s.m34,\n      s.m41,\n      s.m42,\n      s.m43,\n      s.m44\n    ]);\n  throw TypeError(\n    `CSSMatrix: \"${JSON.stringify(s)}\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`\n  );\n}, O = (s) => {\n  if (typeof s != \"string\")\n    throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a string.`);\n  const t = String(s).replace(/\\s/g, \"\");\n  let e = new y();\n  const n = `CSSMatrix: invalid transform string \"${s}\"`;\n  return t.split(\")\").filter((i) => i).forEach((i) => {\n    const [r, a] = i.split(\"(\");\n    if (!a) throw TypeError(n);\n    const l = a.split(\",\").map(\n      (o) => o.includes(\"rad\") ? parseFloat(o) * (180 / Math.PI) : parseFloat(o)\n    ), [m, h, c, u] = l, f = [m, h, c], w = [m, h, c, u];\n    if (r === \"perspective\" && m && [h, c].every((o) => o === void 0))\n      e.m34 = -1 / m;\n    else if (r.includes(\"matrix\") && [6, 16].includes(l.length) && l.every((o) => !Number.isNaN(+o))) {\n      const o = l.map((d) => Math.abs(d) < 1e-6 ? 0 : d);\n      e = e.multiply(g(o));\n    } else if (r === \"translate3d\" && f.every((o) => !Number.isNaN(+o)))\n      e = e.translate(m, h, c);\n    else if (r === \"translate\" && m && c === void 0)\n      e = e.translate(m, h || 0, 0);\n    else if (r === \"rotate3d\" && w.every((o) => !Number.isNaN(+o)) && u)\n      e = e.rotateAxisAngle(m, h, c, u);\n    else if (r === \"rotate\" && m && [h, c].every((o) => o === void 0))\n      e = e.rotate(0, 0, m);\n    else if (r === \"scale3d\" && f.every((o) => !Number.isNaN(+o)) && f.some((o) => o !== 1))\n      e = e.scale(m, h, c);\n    else if (\n      // prop === \"scale\" && !Number.isNaN(x) && x !== 1 && z === undefined\n      // prop === \"scale\" && !Number.isNaN(x) && [x, y].some((n) => n !== 1) &&\n      r === \"scale\" && !Number.isNaN(m) && (m !== 1 || h !== 1) && c === void 0\n    ) {\n      const d = Number.isNaN(+h) ? m : h;\n      e = e.scale(m, d, 1);\n    } else if (r === \"skew\" && (m || !Number.isNaN(m) && h) && c === void 0)\n      e = e.skew(m, h || 0);\n    else if ([\"translate\", \"rotate\", \"scale\", \"skew\"].some(\n      (o) => r.includes(o)\n    ) && /[XYZ]/.test(r) && m && [h, c].every((o) => o === void 0))\n      if (r === \"skewX\" || r === \"skewY\")\n        e = e[r](m);\n      else {\n        const o = r.replace(/[XYZ]/, \"\"), d = r.replace(o, \"\"), A = [\"X\", \"Y\", \"Z\"].indexOf(d), M = o === \"scale\" ? 1 : 0, b = [\n          A === 0 ? m : M,\n          A === 1 ? m : M,\n          A === 2 ? m : M\n        ];\n        e = e[o](...b);\n      }\n    else\n      throw TypeError(n);\n  }), e;\n}, x = (s, t) => t ? [s.a, s.b, s.c, s.d, s.e, s.f] : [\n  s.m11,\n  s.m12,\n  s.m13,\n  s.m14,\n  s.m21,\n  s.m22,\n  s.m23,\n  s.m24,\n  s.m31,\n  s.m32,\n  s.m33,\n  s.m34,\n  s.m41,\n  s.m42,\n  s.m43,\n  s.m44\n], Y = (s, t, e) => {\n  const n = new y();\n  return n.m41 = s, n.e = s, n.m42 = t, n.f = t, n.m43 = e, n;\n}, F = (s, t, e) => {\n  const n = new y(), i = Math.PI / 180, r = s * i, a = t * i, l = e * i, m = Math.cos(r), h = -Math.sin(r), c = Math.cos(a), u = -Math.sin(a), f = Math.cos(l), w = -Math.sin(l), o = c * f, d = -c * w;\n  n.m11 = o, n.a = o, n.m12 = d, n.b = d, n.m13 = u;\n  const A = h * u * f + m * w;\n  n.m21 = A, n.c = A;\n  const M = m * f - h * u * w;\n  return n.m22 = M, n.d = M, n.m23 = -h * c, n.m31 = h * w - m * u * f, n.m32 = h * f + m * u * w, n.m33 = m * c, n;\n}, T = (s, t, e, n) => {\n  const i = new y(), r = Math.sqrt(s * s + t * t + e * e);\n  if (r === 0)\n    return i;\n  const a = s / r, l = t / r, m = e / r, h = n * (Math.PI / 360), c = Math.sin(h), u = Math.cos(h), f = c * c, w = a * a, o = l * l, d = m * m, A = 1 - 2 * (o + d) * f;\n  i.m11 = A, i.a = A;\n  const M = 2 * (a * l * f + m * c * u);\n  i.m12 = M, i.b = M, i.m13 = 2 * (a * m * f - l * c * u);\n  const b = 2 * (l * a * f - m * c * u);\n  i.m21 = b, i.c = b;\n  const k = 1 - 2 * (d + w) * f;\n  return i.m22 = k, i.d = k, i.m23 = 2 * (l * m * f + a * c * u), i.m31 = 2 * (m * a * f + l * c * u), i.m32 = 2 * (m * l * f - a * c * u), i.m33 = 1 - 2 * (w + o) * f, i;\n}, I = (s, t, e) => {\n  const n = new y();\n  return n.m11 = s, n.a = s, n.m22 = t, n.d = t, n.m33 = e, n;\n}, v = (s, t) => {\n  const e = new y();\n  if (s) {\n    const n = s * Math.PI / 180, i = Math.tan(n);\n    e.m21 = i, e.c = i;\n  }\n  if (t) {\n    const n = t * Math.PI / 180, i = Math.tan(n);\n    e.m12 = i, e.b = i;\n  }\n  return e;\n}, R = (s) => v(s, 0), D = (s) => v(0, s), N = (s, t) => {\n  const e = t.m11 * s.m11 + t.m12 * s.m21 + t.m13 * s.m31 + t.m14 * s.m41, n = t.m11 * s.m12 + t.m12 * s.m22 + t.m13 * s.m32 + t.m14 * s.m42, i = t.m11 * s.m13 + t.m12 * s.m23 + t.m13 * s.m33 + t.m14 * s.m43, r = t.m11 * s.m14 + t.m12 * s.m24 + t.m13 * s.m34 + t.m14 * s.m44, a = t.m21 * s.m11 + t.m22 * s.m21 + t.m23 * s.m31 + t.m24 * s.m41, l = t.m21 * s.m12 + t.m22 * s.m22 + t.m23 * s.m32 + t.m24 * s.m42, m = t.m21 * s.m13 + t.m22 * s.m23 + t.m23 * s.m33 + t.m24 * s.m43, h = t.m21 * s.m14 + t.m22 * s.m24 + t.m23 * s.m34 + t.m24 * s.m44, c = t.m31 * s.m11 + t.m32 * s.m21 + t.m33 * s.m31 + t.m34 * s.m41, u = t.m31 * s.m12 + t.m32 * s.m22 + t.m33 * s.m32 + t.m34 * s.m42, f = t.m31 * s.m13 + t.m32 * s.m23 + t.m33 * s.m33 + t.m34 * s.m43, w = t.m31 * s.m14 + t.m32 * s.m24 + t.m33 * s.m34 + t.m34 * s.m44, o = t.m41 * s.m11 + t.m42 * s.m21 + t.m43 * s.m31 + t.m44 * s.m41, d = t.m41 * s.m12 + t.m42 * s.m22 + t.m43 * s.m32 + t.m44 * s.m42, A = t.m41 * s.m13 + t.m42 * s.m23 + t.m43 * s.m33 + t.m44 * s.m43, M = t.m41 * s.m14 + t.m42 * s.m24 + t.m43 * s.m34 + t.m44 * s.m44;\n  return g([\n    e,\n    n,\n    i,\n    r,\n    a,\n    l,\n    m,\n    h,\n    c,\n    u,\n    f,\n    w,\n    o,\n    d,\n    A,\n    M\n  ]);\n};\nclass y {\n  /**\n   * @constructor\n   * @param init accepts all parameter configurations:\n   * * valid CSS transform string,\n   * * CSSMatrix/DOMMatrix instance,\n   * * a 6/16 elements *Array*.\n   */\n  constructor(t) {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this.m11 = 1, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m21 = 0, this.m22 = 1, this.m23 = 0, this.m24 = 0, this.m31 = 0, this.m32 = 0, this.m33 = 1, this.m34 = 0, this.m41 = 0, this.m42 = 0, this.m43 = 0, this.m44 = 1, t ? this.setMatrixValue(t) : this;\n  }\n  /**\n   * A `Boolean` whose value is `true` if the matrix is the identity matrix. The identity\n   * matrix is one in which every value is 0 except those on the main diagonal from top-left\n   * to bottom-right corner (in other words, where the offsets in each direction are equal).\n   *\n   * @return the current property value\n   */\n  get isIdentity() {\n    return this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 && this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 && this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * A `Boolean` flag whose value is `true` if the matrix was initialized as a 2D matrix\n   * and `false` if the matrix is 3D.\n   *\n   * @return the current property value\n   */\n  get is2D() {\n    return this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 && this.m43 === 0 && this.m44 === 1;\n  }\n  /**\n   * The `setMatrixValue` method replaces the existing matrix with one computed\n   * in the browser. EG: `matrix(1,0.25,-0.25,1,0,0)`\n   *\n   * The method accepts any *Array* values, the result of\n   * `DOMMatrix` instance method `toFloat64Array()` / `toFloat32Array()` calls\n   * or `CSSMatrix` instance method `toArray()`.\n   *\n   * This method expects valid *matrix()* / *matrix3d()* string values, as well\n   * as other transform functions like *translateX(10px)*.\n   *\n   * @param source\n   * @return the matrix instance\n   */\n  setMatrixValue(t) {\n    return typeof t == \"string\" && t.length && t !== \"none\" ? O(t) : Array.isArray(t) || t instanceof Float64Array || t instanceof Float32Array ? g(t) : typeof t == \"object\" ? X(t) : this;\n  }\n  /**\n   * Returns a *Float32Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat32Array(t) {\n    return Float32Array.from(x(this, t));\n  }\n  /**\n   * Returns a *Float64Array* containing elements which comprise the matrix.\n   * The method can return either the 16 elements or the 6 elements\n   * depending on the value of the `is2D` parameter.\n   *\n   * @param is2D *Array* representation of the matrix\n   * @return an *Array* representation of the matrix\n   */\n  toFloat64Array(t) {\n    return Float64Array.from(x(this, t));\n  }\n  /**\n   * Creates and returns a string representation of the matrix in `CSS` matrix syntax,\n   * using the appropriate `CSS` matrix notation.\n   *\n   * matrix3d *matrix3d(m11, m12, m13, m14, m21, ...)*\n   * matrix *matrix(a, b, c, d, e, f)*\n   *\n   * @return a string representation of the matrix\n   */\n  toString() {\n    const { is2D: t } = this, e = this.toFloat64Array(t).join(\", \");\n    return `${t ? \"matrix\" : \"matrix3d\"}(${e})`;\n  }\n  /**\n   * Returns a JSON representation of the `CSSMatrix` instance, a standard *Object*\n   * that includes `{a,b,c,d,e,f}` and `{m11,m12,m13,..m44}` properties as well\n   * as the `is2D` & `isIdentity` properties.\n   *\n   * The result can also be used as a second parameter for the `fromMatrix` static method\n   * to load values into another matrix instance.\n   *\n   * @return an *Object* with all matrix values.\n   */\n  toJSON() {\n    const { is2D: t, isIdentity: e } = this;\n    return { ...this, is2D: t, isIdentity: e };\n  }\n  /**\n   * The Multiply method returns a new CSSMatrix which is the result of this\n   * matrix multiplied by the passed matrix, with the passed matrix to the right.\n   * This matrix is not modified.\n   *\n   * @param m2 CSSMatrix\n   * @return The resulted matrix.\n   */\n  multiply(t) {\n    return N(this, t);\n  }\n  /**\n   * The translate method returns a new matrix which is this matrix post\n   * multiplied by a translation matrix containing the passed values. If the z\n   * component is undefined, a 0 value is used in its place. This matrix is not\n   * modified.\n   *\n   * @param x X component of the translation value.\n   * @param y Y component of the translation value.\n   * @param z Z component of the translation value.\n   * @return The resulted matrix\n   */\n  translate(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = 0), typeof a > \"u\" && (a = 0), N(this, Y(i, r, a));\n  }\n  /**\n   * The scale method returns a new matrix which is this matrix post multiplied by\n   * a scale matrix containing the passed values. If the z component is undefined,\n   * a 1 value is used in its place. If the y component is undefined, the x\n   * component value is used in its place. This matrix is not modified.\n   *\n   * @param x The X component of the scale value.\n   * @param y The Y component of the scale value.\n   * @param z The Z component of the scale value.\n   * @return The resulted matrix\n   */\n  scale(t, e, n) {\n    const i = t;\n    let r = e, a = n;\n    return typeof r > \"u\" && (r = t), typeof a > \"u\" && (a = 1), N(this, I(i, r, a));\n  }\n  /**\n   * The rotate method returns a new matrix which is this matrix post multiplied\n   * by each of 3 rotation matrices about the major axes, first X, then Y, then Z.\n   * If the y and z components are undefined, the x value is used to rotate the\n   * object about the z axis, as though the vector (0,0,x) were passed. All\n   * rotation values are in degrees. This matrix is not modified.\n   *\n   * @param rx The X component of the rotation, or Z if Y and Z are null.\n   * @param ry The (optional) Y component of the rotation value.\n   * @param rz The (optional) Z component of the rotation value.\n   * @return The resulted matrix\n   */\n  rotate(t, e, n) {\n    let i = t, r = e || 0, a = n || 0;\n    return typeof t == \"number\" && typeof e > \"u\" && typeof n > \"u\" && (a = i, i = 0, r = 0), N(this, F(i, r, a));\n  }\n  /**\n   * The rotateAxisAngle method returns a new matrix which is this matrix post\n   * multiplied by a rotation matrix with the given axis and `angle`. The right-hand\n   * rule is used to determine the direction of rotation. All rotation values are\n   * in degrees. This matrix is not modified.\n   *\n   * @param x The X component of the axis vector.\n   * @param y The Y component of the axis vector.\n   * @param z The Z component of the axis vector.\n   * @param angle The angle of rotation about the axis vector, in degrees.\n   * @return The resulted matrix\n   */\n  rotateAxisAngle(t, e, n, i) {\n    if ([t, e, n, i].some((r) => Number.isNaN(+r)))\n      throw new TypeError(\"CSSMatrix: expecting 4 values\");\n    return N(this, T(t, e, n, i));\n  }\n  /**\n   * Specifies a skew transformation along the `x-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewX(t) {\n    return N(this, R(t));\n  }\n  /**\n   * Specifies a skew transformation along the `y-axis` by the given angle.\n   * This matrix is not modified.\n   *\n   * @param angle The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skewY(t) {\n    return N(this, D(t));\n  }\n  /**\n   * Specifies a skew transformation along both the `x-axis` and `y-axis`.\n   * This matrix is not modified.\n   *\n   * @param angleX The X-angle amount in degrees to skew.\n   * @param angleY The angle amount in degrees to skew.\n   * @return The resulted matrix\n   */\n  skew(t, e) {\n    return N(this, v(t, e));\n  }\n  /**\n   * Transforms a specified vector using the matrix, returning a new\n   * {x,y,z,w} Tuple *Object* comprising the transformed vector.\n   * Neither the matrix nor the original vector are altered.\n   *\n   * The method is equivalent with `transformPoint()` method\n   * of the `DOMMatrix` constructor.\n   *\n   * @param t Tuple with `{x,y,z,w}` components\n   * @return the resulting Tuple\n   */\n  transformPoint(t) {\n    const e = this.m11 * t.x + this.m21 * t.y + this.m31 * t.z + this.m41 * t.w, n = this.m12 * t.x + this.m22 * t.y + this.m32 * t.z + this.m42 * t.w, i = this.m13 * t.x + this.m23 * t.y + this.m33 * t.z + this.m43 * t.w, r = this.m14 * t.x + this.m24 * t.y + this.m34 * t.z + this.m44 * t.w;\n    return t instanceof DOMPoint ? new DOMPoint(e, n, i, r) : {\n      x: e,\n      y: n,\n      z: i,\n      w: r\n    };\n  }\n}\np(y, \"Translate\", Y), p(y, \"Rotate\", F), p(y, \"RotateAxisAngle\", T), p(y, \"Scale\", I), p(y, \"SkewX\", R), p(y, \"SkewY\", D), p(y, \"Skew\", v), p(y, \"Multiply\", N), p(y, \"fromArray\", g), p(y, \"fromMatrix\", X), p(y, \"fromString\", O), p(y, \"toArray\", x), p(y, \"isCompatibleArray\", E), p(y, \"isCompatibleObject\", P);\n\n//# sourceMappingURL=dommatrix.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRoZWRucC9kb21tYXRyaXgvZGlzdC9kb21tYXRyaXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLHdDQUF3QywwREFBMEQ7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLENBQUM7QUFDRDtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGNBQWMsMEJBQTBCLEdBQUcsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxRQUFRLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvY3ljbGVyc3MvRG93bmxvYWRzL0NMQy0wNTAyL25vZGVfbW9kdWxlcy9AdGhlZG5wL2RvbW1hdHJpeC9kaXN0L2RvbW1hdHJpeC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFogPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgeiA9IChzLCB0LCBlKSA9PiB0IGluIHMgPyBaKHMsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IGUgfSkgOiBzW3RdID0gZTtcbnZhciBwID0gKHMsIHQsIGUpID0+IHoocywgdHlwZW9mIHQgIT0gXCJzeW1ib2xcIiA/IHQgKyBcIlwiIDogdCwgZSk7XG5jb25zdCAkID0ge1xuICBhOiAxLFxuICBiOiAwLFxuICBjOiAwLFxuICBkOiAxLFxuICBlOiAwLFxuICBmOiAwLFxuICBtMTE6IDEsXG4gIG0xMjogMCxcbiAgbTEzOiAwLFxuICBtMTQ6IDAsXG4gIG0yMTogMCxcbiAgbTIyOiAxLFxuICBtMjM6IDAsXG4gIG0yNDogMCxcbiAgbTMxOiAwLFxuICBtMzI6IDAsXG4gIG0zMzogMSxcbiAgbTM0OiAwLFxuICBtNDE6IDAsXG4gIG00MjogMCxcbiAgbTQzOiAwLFxuICBtNDQ6IDEsXG4gIGlzMkQ6ICEwLFxuICBpc0lkZW50aXR5OiAhMFxufSwgRSA9IChzKSA9PiAocyBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fCBzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IEFycmF5LmlzQXJyYXkocykgJiYgcy5ldmVyeSgodCkgPT4gdHlwZW9mIHQgPT0gXCJudW1iZXJcIikpICYmIFs2LCAxNl0uc29tZSgodCkgPT4gcy5sZW5ndGggPT09IHQpLCBQID0gKHMpID0+IHMgaW5zdGFuY2VvZiBET01NYXRyaXggfHwgcyBpbnN0YW5jZW9mIHkgfHwgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cygkKS5ldmVyeSgodCkgPT4gcyAmJiB0IGluIHMpLCBnID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IG5ldyB5KCksIGUgPSBBcnJheS5mcm9tKHMpO1xuICBpZiAoIUUoZSkpXG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgYENTU01hdHJpeDogXCIke2Uuam9pbihcIixcIil9XCIgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDYvMTYgbnVtYmVycy5gXG4gICAgKTtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2UgQHByZXNlcnZlXG4gIGlmIChlLmxlbmd0aCA9PT0gMTYpIHtcbiAgICBjb25zdCBbXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbCxcbiAgICAgIG0sXG4gICAgICBoLFxuICAgICAgYyxcbiAgICAgIHUsXG4gICAgICBmLFxuICAgICAgdyxcbiAgICAgIG8sXG4gICAgICBkLFxuICAgICAgQSxcbiAgICAgIE0sXG4gICAgICBiXG4gICAgXSA9IGU7XG4gICAgdC5tMTEgPSBuLCB0LmEgPSBuLCB0Lm0yMSA9IGwsIHQuYyA9IGwsIHQubTMxID0gdSwgdC5tNDEgPSBkLCB0LmUgPSBkLCB0Lm0xMiA9IGksIHQuYiA9IGksIHQubTIyID0gbSwgdC5kID0gbSwgdC5tMzIgPSBmLCB0Lm00MiA9IEEsIHQuZiA9IEEsIHQubTEzID0gciwgdC5tMjMgPSBoLCB0Lm0zMyA9IHcsIHQubTQzID0gTSwgdC5tMTQgPSBhLCB0Lm0yNCA9IGMsIHQubTM0ID0gbywgdC5tNDQgPSBiO1xuICB9IGVsc2UgaWYgKGUubGVuZ3RoID09PSA2KSB7XG4gICAgY29uc3QgW24sIGksIHIsIGEsIGwsIG1dID0gZTtcbiAgICB0Lm0xMSA9IG4sIHQuYSA9IG4sIHQubTEyID0gaSwgdC5iID0gaSwgdC5tMjEgPSByLCB0LmMgPSByLCB0Lm0yMiA9IGEsIHQuZCA9IGEsIHQubTQxID0gbCwgdC5lID0gbCwgdC5tNDIgPSBtLCB0LmYgPSBtO1xuICB9XG4gIHJldHVybiB0O1xufSwgWCA9IChzKSA9PiB7XG4gIGlmIChQKHMpKVxuICAgIHJldHVybiBnKFtcbiAgICAgIHMubTExLFxuICAgICAgcy5tMTIsXG4gICAgICBzLm0xMyxcbiAgICAgIHMubTE0LFxuICAgICAgcy5tMjEsXG4gICAgICBzLm0yMixcbiAgICAgIHMubTIzLFxuICAgICAgcy5tMjQsXG4gICAgICBzLm0zMSxcbiAgICAgIHMubTMyLFxuICAgICAgcy5tMzMsXG4gICAgICBzLm0zNCxcbiAgICAgIHMubTQxLFxuICAgICAgcy5tNDIsXG4gICAgICBzLm00MyxcbiAgICAgIHMubTQ0XG4gICAgXSk7XG4gIHRocm93IFR5cGVFcnJvcihcbiAgICBgQ1NTTWF0cml4OiBcIiR7SlNPTi5zdHJpbmdpZnkocyl9XCIgaXMgbm90IGEgRE9NTWF0cml4IC8gQ1NTTWF0cml4IC8gSlNPTiBjb21wYXRpYmxlIG9iamVjdC5gXG4gICk7XG59LCBPID0gKHMpID0+IHtcbiAgaWYgKHR5cGVvZiBzICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgVHlwZUVycm9yKGBDU1NNYXRyaXg6IFwiJHtKU09OLnN0cmluZ2lmeShzKX1cIiBpcyBub3QgYSBzdHJpbmcuYCk7XG4gIGNvbnN0IHQgPSBTdHJpbmcocykucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xuICBsZXQgZSA9IG5ldyB5KCk7XG4gIGNvbnN0IG4gPSBgQ1NTTWF0cml4OiBpbnZhbGlkIHRyYW5zZm9ybSBzdHJpbmcgXCIke3N9XCJgO1xuICByZXR1cm4gdC5zcGxpdChcIilcIikuZmlsdGVyKChpKSA9PiBpKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgY29uc3QgW3IsIGFdID0gaS5zcGxpdChcIihcIik7XG4gICAgaWYgKCFhKSB0aHJvdyBUeXBlRXJyb3Iobik7XG4gICAgY29uc3QgbCA9IGEuc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgIChvKSA9PiBvLmluY2x1ZGVzKFwicmFkXCIpID8gcGFyc2VGbG9hdChvKSAqICgxODAgLyBNYXRoLlBJKSA6IHBhcnNlRmxvYXQobylcbiAgICApLCBbbSwgaCwgYywgdV0gPSBsLCBmID0gW20sIGgsIGNdLCB3ID0gW20sIGgsIGMsIHVdO1xuICAgIGlmIChyID09PSBcInBlcnNwZWN0aXZlXCIgJiYgbSAmJiBbaCwgY10uZXZlcnkoKG8pID0+IG8gPT09IHZvaWQgMCkpXG4gICAgICBlLm0zNCA9IC0xIC8gbTtcbiAgICBlbHNlIGlmIChyLmluY2x1ZGVzKFwibWF0cml4XCIpICYmIFs2LCAxNl0uaW5jbHVkZXMobC5sZW5ndGgpICYmIGwuZXZlcnkoKG8pID0+ICFOdW1iZXIuaXNOYU4oK28pKSkge1xuICAgICAgY29uc3QgbyA9IGwubWFwKChkKSA9PiBNYXRoLmFicyhkKSA8IDFlLTYgPyAwIDogZCk7XG4gICAgICBlID0gZS5tdWx0aXBseShnKG8pKTtcbiAgICB9IGVsc2UgaWYgKHIgPT09IFwidHJhbnNsYXRlM2RcIiAmJiBmLmV2ZXJ5KChvKSA9PiAhTnVtYmVyLmlzTmFOKCtvKSkpXG4gICAgICBlID0gZS50cmFuc2xhdGUobSwgaCwgYyk7XG4gICAgZWxzZSBpZiAociA9PT0gXCJ0cmFuc2xhdGVcIiAmJiBtICYmIGMgPT09IHZvaWQgMClcbiAgICAgIGUgPSBlLnRyYW5zbGF0ZShtLCBoIHx8IDAsIDApO1xuICAgIGVsc2UgaWYgKHIgPT09IFwicm90YXRlM2RcIiAmJiB3LmV2ZXJ5KChvKSA9PiAhTnVtYmVyLmlzTmFOKCtvKSkgJiYgdSlcbiAgICAgIGUgPSBlLnJvdGF0ZUF4aXNBbmdsZShtLCBoLCBjLCB1KTtcbiAgICBlbHNlIGlmIChyID09PSBcInJvdGF0ZVwiICYmIG0gJiYgW2gsIGNdLmV2ZXJ5KChvKSA9PiBvID09PSB2b2lkIDApKVxuICAgICAgZSA9IGUucm90YXRlKDAsIDAsIG0pO1xuICAgIGVsc2UgaWYgKHIgPT09IFwic2NhbGUzZFwiICYmIGYuZXZlcnkoKG8pID0+ICFOdW1iZXIuaXNOYU4oK28pKSAmJiBmLnNvbWUoKG8pID0+IG8gIT09IDEpKVxuICAgICAgZSA9IGUuc2NhbGUobSwgaCwgYyk7XG4gICAgZWxzZSBpZiAoXG4gICAgICAvLyBwcm9wID09PSBcInNjYWxlXCIgJiYgIU51bWJlci5pc05hTih4KSAmJiB4ICE9PSAxICYmIHogPT09IHVuZGVmaW5lZFxuICAgICAgLy8gcHJvcCA9PT0gXCJzY2FsZVwiICYmICFOdW1iZXIuaXNOYU4oeCkgJiYgW3gsIHldLnNvbWUoKG4pID0+IG4gIT09IDEpICYmXG4gICAgICByID09PSBcInNjYWxlXCIgJiYgIU51bWJlci5pc05hTihtKSAmJiAobSAhPT0gMSB8fCBoICE9PSAxKSAmJiBjID09PSB2b2lkIDBcbiAgICApIHtcbiAgICAgIGNvbnN0IGQgPSBOdW1iZXIuaXNOYU4oK2gpID8gbSA6IGg7XG4gICAgICBlID0gZS5zY2FsZShtLCBkLCAxKTtcbiAgICB9IGVsc2UgaWYgKHIgPT09IFwic2tld1wiICYmIChtIHx8ICFOdW1iZXIuaXNOYU4obSkgJiYgaCkgJiYgYyA9PT0gdm9pZCAwKVxuICAgICAgZSA9IGUuc2tldyhtLCBoIHx8IDApO1xuICAgIGVsc2UgaWYgKFtcInRyYW5zbGF0ZVwiLCBcInJvdGF0ZVwiLCBcInNjYWxlXCIsIFwic2tld1wiXS5zb21lKFxuICAgICAgKG8pID0+IHIuaW5jbHVkZXMobylcbiAgICApICYmIC9bWFlaXS8udGVzdChyKSAmJiBtICYmIFtoLCBjXS5ldmVyeSgobykgPT4gbyA9PT0gdm9pZCAwKSlcbiAgICAgIGlmIChyID09PSBcInNrZXdYXCIgfHwgciA9PT0gXCJza2V3WVwiKVxuICAgICAgICBlID0gZVtyXShtKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvID0gci5yZXBsYWNlKC9bWFlaXS8sIFwiXCIpLCBkID0gci5yZXBsYWNlKG8sIFwiXCIpLCBBID0gW1wiWFwiLCBcIllcIiwgXCJaXCJdLmluZGV4T2YoZCksIE0gPSBvID09PSBcInNjYWxlXCIgPyAxIDogMCwgYiA9IFtcbiAgICAgICAgICBBID09PSAwID8gbSA6IE0sXG4gICAgICAgICAgQSA9PT0gMSA/IG0gOiBNLFxuICAgICAgICAgIEEgPT09IDIgPyBtIDogTVxuICAgICAgICBdO1xuICAgICAgICBlID0gZVtvXSguLi5iKTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB0aHJvdyBUeXBlRXJyb3Iobik7XG4gIH0pLCBlO1xufSwgeCA9IChzLCB0KSA9PiB0ID8gW3MuYSwgcy5iLCBzLmMsIHMuZCwgcy5lLCBzLmZdIDogW1xuICBzLm0xMSxcbiAgcy5tMTIsXG4gIHMubTEzLFxuICBzLm0xNCxcbiAgcy5tMjEsXG4gIHMubTIyLFxuICBzLm0yMyxcbiAgcy5tMjQsXG4gIHMubTMxLFxuICBzLm0zMixcbiAgcy5tMzMsXG4gIHMubTM0LFxuICBzLm00MSxcbiAgcy5tNDIsXG4gIHMubTQzLFxuICBzLm00NFxuXSwgWSA9IChzLCB0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSBuZXcgeSgpO1xuICByZXR1cm4gbi5tNDEgPSBzLCBuLmUgPSBzLCBuLm00MiA9IHQsIG4uZiA9IHQsIG4ubTQzID0gZSwgbjtcbn0sIEYgPSAocywgdCwgZSkgPT4ge1xuICBjb25zdCBuID0gbmV3IHkoKSwgaSA9IE1hdGguUEkgLyAxODAsIHIgPSBzICogaSwgYSA9IHQgKiBpLCBsID0gZSAqIGksIG0gPSBNYXRoLmNvcyhyKSwgaCA9IC1NYXRoLnNpbihyKSwgYyA9IE1hdGguY29zKGEpLCB1ID0gLU1hdGguc2luKGEpLCBmID0gTWF0aC5jb3MobCksIHcgPSAtTWF0aC5zaW4obCksIG8gPSBjICogZiwgZCA9IC1jICogdztcbiAgbi5tMTEgPSBvLCBuLmEgPSBvLCBuLm0xMiA9IGQsIG4uYiA9IGQsIG4ubTEzID0gdTtcbiAgY29uc3QgQSA9IGggKiB1ICogZiArIG0gKiB3O1xuICBuLm0yMSA9IEEsIG4uYyA9IEE7XG4gIGNvbnN0IE0gPSBtICogZiAtIGggKiB1ICogdztcbiAgcmV0dXJuIG4ubTIyID0gTSwgbi5kID0gTSwgbi5tMjMgPSAtaCAqIGMsIG4ubTMxID0gaCAqIHcgLSBtICogdSAqIGYsIG4ubTMyID0gaCAqIGYgKyBtICogdSAqIHcsIG4ubTMzID0gbSAqIGMsIG47XG59LCBUID0gKHMsIHQsIGUsIG4pID0+IHtcbiAgY29uc3QgaSA9IG5ldyB5KCksIHIgPSBNYXRoLnNxcnQocyAqIHMgKyB0ICogdCArIGUgKiBlKTtcbiAgaWYgKHIgPT09IDApXG4gICAgcmV0dXJuIGk7XG4gIGNvbnN0IGEgPSBzIC8gciwgbCA9IHQgLyByLCBtID0gZSAvIHIsIGggPSBuICogKE1hdGguUEkgLyAzNjApLCBjID0gTWF0aC5zaW4oaCksIHUgPSBNYXRoLmNvcyhoKSwgZiA9IGMgKiBjLCB3ID0gYSAqIGEsIG8gPSBsICogbCwgZCA9IG0gKiBtLCBBID0gMSAtIDIgKiAobyArIGQpICogZjtcbiAgaS5tMTEgPSBBLCBpLmEgPSBBO1xuICBjb25zdCBNID0gMiAqIChhICogbCAqIGYgKyBtICogYyAqIHUpO1xuICBpLm0xMiA9IE0sIGkuYiA9IE0sIGkubTEzID0gMiAqIChhICogbSAqIGYgLSBsICogYyAqIHUpO1xuICBjb25zdCBiID0gMiAqIChsICogYSAqIGYgLSBtICogYyAqIHUpO1xuICBpLm0yMSA9IGIsIGkuYyA9IGI7XG4gIGNvbnN0IGsgPSAxIC0gMiAqIChkICsgdykgKiBmO1xuICByZXR1cm4gaS5tMjIgPSBrLCBpLmQgPSBrLCBpLm0yMyA9IDIgKiAobCAqIG0gKiBmICsgYSAqIGMgKiB1KSwgaS5tMzEgPSAyICogKG0gKiBhICogZiArIGwgKiBjICogdSksIGkubTMyID0gMiAqIChtICogbCAqIGYgLSBhICogYyAqIHUpLCBpLm0zMyA9IDEgLSAyICogKHcgKyBvKSAqIGYsIGk7XG59LCBJID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IG5ldyB5KCk7XG4gIHJldHVybiBuLm0xMSA9IHMsIG4uYSA9IHMsIG4ubTIyID0gdCwgbi5kID0gdCwgbi5tMzMgPSBlLCBuO1xufSwgdiA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBuZXcgeSgpO1xuICBpZiAocykge1xuICAgIGNvbnN0IG4gPSBzICogTWF0aC5QSSAvIDE4MCwgaSA9IE1hdGgudGFuKG4pO1xuICAgIGUubTIxID0gaSwgZS5jID0gaTtcbiAgfVxuICBpZiAodCkge1xuICAgIGNvbnN0IG4gPSB0ICogTWF0aC5QSSAvIDE4MCwgaSA9IE1hdGgudGFuKG4pO1xuICAgIGUubTEyID0gaSwgZS5iID0gaTtcbiAgfVxuICByZXR1cm4gZTtcbn0sIFIgPSAocykgPT4gdihzLCAwKSwgRCA9IChzKSA9PiB2KDAsIHMpLCBOID0gKHMsIHQpID0+IHtcbiAgY29uc3QgZSA9IHQubTExICogcy5tMTEgKyB0Lm0xMiAqIHMubTIxICsgdC5tMTMgKiBzLm0zMSArIHQubTE0ICogcy5tNDEsIG4gPSB0Lm0xMSAqIHMubTEyICsgdC5tMTIgKiBzLm0yMiArIHQubTEzICogcy5tMzIgKyB0Lm0xNCAqIHMubTQyLCBpID0gdC5tMTEgKiBzLm0xMyArIHQubTEyICogcy5tMjMgKyB0Lm0xMyAqIHMubTMzICsgdC5tMTQgKiBzLm00MywgciA9IHQubTExICogcy5tMTQgKyB0Lm0xMiAqIHMubTI0ICsgdC5tMTMgKiBzLm0zNCArIHQubTE0ICogcy5tNDQsIGEgPSB0Lm0yMSAqIHMubTExICsgdC5tMjIgKiBzLm0yMSArIHQubTIzICogcy5tMzEgKyB0Lm0yNCAqIHMubTQxLCBsID0gdC5tMjEgKiBzLm0xMiArIHQubTIyICogcy5tMjIgKyB0Lm0yMyAqIHMubTMyICsgdC5tMjQgKiBzLm00MiwgbSA9IHQubTIxICogcy5tMTMgKyB0Lm0yMiAqIHMubTIzICsgdC5tMjMgKiBzLm0zMyArIHQubTI0ICogcy5tNDMsIGggPSB0Lm0yMSAqIHMubTE0ICsgdC5tMjIgKiBzLm0yNCArIHQubTIzICogcy5tMzQgKyB0Lm0yNCAqIHMubTQ0LCBjID0gdC5tMzEgKiBzLm0xMSArIHQubTMyICogcy5tMjEgKyB0Lm0zMyAqIHMubTMxICsgdC5tMzQgKiBzLm00MSwgdSA9IHQubTMxICogcy5tMTIgKyB0Lm0zMiAqIHMubTIyICsgdC5tMzMgKiBzLm0zMiArIHQubTM0ICogcy5tNDIsIGYgPSB0Lm0zMSAqIHMubTEzICsgdC5tMzIgKiBzLm0yMyArIHQubTMzICogcy5tMzMgKyB0Lm0zNCAqIHMubTQzLCB3ID0gdC5tMzEgKiBzLm0xNCArIHQubTMyICogcy5tMjQgKyB0Lm0zMyAqIHMubTM0ICsgdC5tMzQgKiBzLm00NCwgbyA9IHQubTQxICogcy5tMTEgKyB0Lm00MiAqIHMubTIxICsgdC5tNDMgKiBzLm0zMSArIHQubTQ0ICogcy5tNDEsIGQgPSB0Lm00MSAqIHMubTEyICsgdC5tNDIgKiBzLm0yMiArIHQubTQzICogcy5tMzIgKyB0Lm00NCAqIHMubTQyLCBBID0gdC5tNDEgKiBzLm0xMyArIHQubTQyICogcy5tMjMgKyB0Lm00MyAqIHMubTMzICsgdC5tNDQgKiBzLm00MywgTSA9IHQubTQxICogcy5tMTQgKyB0Lm00MiAqIHMubTI0ICsgdC5tNDMgKiBzLm0zNCArIHQubTQ0ICogcy5tNDQ7XG4gIHJldHVybiBnKFtcbiAgICBlLFxuICAgIG4sXG4gICAgaSxcbiAgICByLFxuICAgIGEsXG4gICAgbCxcbiAgICBtLFxuICAgIGgsXG4gICAgYyxcbiAgICB1LFxuICAgIGYsXG4gICAgdyxcbiAgICBvLFxuICAgIGQsXG4gICAgQSxcbiAgICBNXG4gIF0pO1xufTtcbmNsYXNzIHkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBpbml0IGFjY2VwdHMgYWxsIHBhcmFtZXRlciBjb25maWd1cmF0aW9uczpcbiAgICogKiB2YWxpZCBDU1MgdHJhbnNmb3JtIHN0cmluZyxcbiAgICogKiBDU1NNYXRyaXgvRE9NTWF0cml4IGluc3RhbmNlLFxuICAgKiAqIGEgNi8xNiBlbGVtZW50cyAqQXJyYXkqLlxuICAgKi9cbiAgY29uc3RydWN0b3IodCkge1xuICAgIHJldHVybiB0aGlzLmEgPSAxLCB0aGlzLmIgPSAwLCB0aGlzLmMgPSAwLCB0aGlzLmQgPSAxLCB0aGlzLmUgPSAwLCB0aGlzLmYgPSAwLCB0aGlzLm0xMSA9IDEsIHRoaXMubTEyID0gMCwgdGhpcy5tMTMgPSAwLCB0aGlzLm0xNCA9IDAsIHRoaXMubTIxID0gMCwgdGhpcy5tMjIgPSAxLCB0aGlzLm0yMyA9IDAsIHRoaXMubTI0ID0gMCwgdGhpcy5tMzEgPSAwLCB0aGlzLm0zMiA9IDAsIHRoaXMubTMzID0gMSwgdGhpcy5tMzQgPSAwLCB0aGlzLm00MSA9IDAsIHRoaXMubTQyID0gMCwgdGhpcy5tNDMgPSAwLCB0aGlzLm00NCA9IDEsIHQgPyB0aGlzLnNldE1hdHJpeFZhbHVlKHQpIDogdGhpcztcbiAgfVxuICAvKipcbiAgICogQSBgQm9vbGVhbmAgd2hvc2UgdmFsdWUgaXMgYHRydWVgIGlmIHRoZSBtYXRyaXggaXMgdGhlIGlkZW50aXR5IG1hdHJpeC4gVGhlIGlkZW50aXR5XG4gICAqIG1hdHJpeCBpcyBvbmUgaW4gd2hpY2ggZXZlcnkgdmFsdWUgaXMgMCBleGNlcHQgdGhvc2Ugb24gdGhlIG1haW4gZGlhZ29uYWwgZnJvbSB0b3AtbGVmdFxuICAgKiB0byBib3R0b20tcmlnaHQgY29ybmVyIChpbiBvdGhlciB3b3Jkcywgd2hlcmUgdGhlIG9mZnNldHMgaW4gZWFjaCBkaXJlY3Rpb24gYXJlIGVxdWFsKS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgZ2V0IGlzSWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubTExID09PSAxICYmIHRoaXMubTEyID09PSAwICYmIHRoaXMubTEzID09PSAwICYmIHRoaXMubTE0ID09PSAwICYmIHRoaXMubTIxID09PSAwICYmIHRoaXMubTIyID09PSAxICYmIHRoaXMubTIzID09PSAwICYmIHRoaXMubTI0ID09PSAwICYmIHRoaXMubTMxID09PSAwICYmIHRoaXMubTMyID09PSAwICYmIHRoaXMubTMzID09PSAxICYmIHRoaXMubTM0ID09PSAwICYmIHRoaXMubTQxID09PSAwICYmIHRoaXMubTQyID09PSAwICYmIHRoaXMubTQzID09PSAwICYmIHRoaXMubTQ0ID09PSAxO1xuICB9XG4gIC8qKlxuICAgKiBBIGBCb29sZWFuYCBmbGFnIHdob3NlIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgbWF0cml4IHdhcyBpbml0aWFsaXplZCBhcyBhIDJEIG1hdHJpeFxuICAgKiBhbmQgYGZhbHNlYCBpZiB0aGUgbWF0cml4IGlzIDNELlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBnZXQgaXMyRCgpIHtcbiAgICByZXR1cm4gdGhpcy5tMzEgPT09IDAgJiYgdGhpcy5tMzIgPT09IDAgJiYgdGhpcy5tMzMgPT09IDEgJiYgdGhpcy5tMzQgPT09IDAgJiYgdGhpcy5tNDMgPT09IDAgJiYgdGhpcy5tNDQgPT09IDE7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgc2V0TWF0cml4VmFsdWVgIG1ldGhvZCByZXBsYWNlcyB0aGUgZXhpc3RpbmcgbWF0cml4IHdpdGggb25lIGNvbXB1dGVkXG4gICAqIGluIHRoZSBicm93c2VyLiBFRzogYG1hdHJpeCgxLDAuMjUsLTAuMjUsMSwwLDApYFxuICAgKlxuICAgKiBUaGUgbWV0aG9kIGFjY2VwdHMgYW55ICpBcnJheSogdmFsdWVzLCB0aGUgcmVzdWx0IG9mXG4gICAqIGBET01NYXRyaXhgIGluc3RhbmNlIG1ldGhvZCBgdG9GbG9hdDY0QXJyYXkoKWAgLyBgdG9GbG9hdDMyQXJyYXkoKWAgY2FsbHNcbiAgICogb3IgYENTU01hdHJpeGAgaW5zdGFuY2UgbWV0aG9kIGB0b0FycmF5KClgLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBleHBlY3RzIHZhbGlkICptYXRyaXgoKSogLyAqbWF0cml4M2QoKSogc3RyaW5nIHZhbHVlcywgYXMgd2VsbFxuICAgKiBhcyBvdGhlciB0cmFuc2Zvcm0gZnVuY3Rpb25zIGxpa2UgKnRyYW5zbGF0ZVgoMTBweCkqLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlXG4gICAqIEByZXR1cm4gdGhlIG1hdHJpeCBpbnN0YW5jZVxuICAgKi9cbiAgc2V0TWF0cml4VmFsdWUodCkge1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIHQubGVuZ3RoICYmIHQgIT09IFwibm9uZVwiID8gTyh0KSA6IEFycmF5LmlzQXJyYXkodCkgfHwgdCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fCB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gZyh0KSA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyBYKHQpIDogdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhICpGbG9hdDMyQXJyYXkqIGNvbnRhaW5pbmcgZWxlbWVudHMgd2hpY2ggY29tcHJpc2UgdGhlIG1hdHJpeC5cbiAgICogVGhlIG1ldGhvZCBjYW4gcmV0dXJuIGVpdGhlciB0aGUgMTYgZWxlbWVudHMgb3IgdGhlIDYgZWxlbWVudHNcbiAgICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB0aGUgYGlzMkRgIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIGlzMkQgKkFycmF5KiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAqIEByZXR1cm4gYW4gKkFycmF5KiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAqL1xuICB0b0Zsb2F0MzJBcnJheSh0KSB7XG4gICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKHgodGhpcywgdCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgKkZsb2F0NjRBcnJheSogY29udGFpbmluZyBlbGVtZW50cyB3aGljaCBjb21wcmlzZSB0aGUgbWF0cml4LlxuICAgKiBUaGUgbWV0aG9kIGNhbiByZXR1cm4gZWl0aGVyIHRoZSAxNiBlbGVtZW50cyBvciB0aGUgNiBlbGVtZW50c1xuICAgKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoZSBgaXMyRGAgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gaXMyRCAqQXJyYXkqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAgICogQHJldHVybiBhbiAqQXJyYXkqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAgICovXG4gIHRvRmxvYXQ2NEFycmF5KHQpIHtcbiAgICByZXR1cm4gRmxvYXQ2NEFycmF5LmZyb20oeCh0aGlzLCB0KSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeCBpbiBgQ1NTYCBtYXRyaXggc3ludGF4LFxuICAgKiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYENTU2AgbWF0cml4IG5vdGF0aW9uLlxuICAgKlxuICAgKiBtYXRyaXgzZCAqbWF0cml4M2QobTExLCBtMTIsIG0xMywgbTE0LCBtMjEsIC4uLikqXG4gICAqIG1hdHJpeCAqbWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpKlxuICAgKlxuICAgKiBAcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHsgaXMyRDogdCB9ID0gdGhpcywgZSA9IHRoaXMudG9GbG9hdDY0QXJyYXkodCkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBgJHt0ID8gXCJtYXRyaXhcIiA6IFwibWF0cml4M2RcIn0oJHtlfSlgO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgYENTU01hdHJpeGAgaW5zdGFuY2UsIGEgc3RhbmRhcmQgKk9iamVjdCpcbiAgICogdGhhdCBpbmNsdWRlcyBge2EsYixjLGQsZSxmfWAgYW5kIGB7bTExLG0xMixtMTMsLi5tNDR9YCBwcm9wZXJ0aWVzIGFzIHdlbGxcbiAgICogYXMgdGhlIGBpczJEYCAmIGBpc0lkZW50aXR5YCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0IGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBzZWNvbmQgcGFyYW1ldGVyIGZvciB0aGUgYGZyb21NYXRyaXhgIHN0YXRpYyBtZXRob2RcbiAgICogdG8gbG9hZCB2YWx1ZXMgaW50byBhbm90aGVyIG1hdHJpeCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHJldHVybiBhbiAqT2JqZWN0KiB3aXRoIGFsbCBtYXRyaXggdmFsdWVzLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHsgaXMyRDogdCwgaXNJZGVudGl0eTogZSB9ID0gdGhpcztcbiAgICByZXR1cm4geyAuLi50aGlzLCBpczJEOiB0LCBpc0lkZW50aXR5OiBlIH07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNdWx0aXBseSBtZXRob2QgcmV0dXJucyBhIG5ldyBDU1NNYXRyaXggd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiB0aGlzXG4gICAqIG1hdHJpeCBtdWx0aXBsaWVkIGJ5IHRoZSBwYXNzZWQgbWF0cml4LCB3aXRoIHRoZSBwYXNzZWQgbWF0cml4IHRvIHRoZSByaWdodC5cbiAgICogVGhpcyBtYXRyaXggaXMgbm90IG1vZGlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0gbTIgQ1NTTWF0cml4XG4gICAqIEByZXR1cm4gVGhlIHJlc3VsdGVkIG1hdHJpeC5cbiAgICovXG4gIG11bHRpcGx5KHQpIHtcbiAgICByZXR1cm4gTih0aGlzLCB0KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRyYW5zbGF0ZSBtZXRob2QgcmV0dXJucyBhIG5ldyBtYXRyaXggd2hpY2ggaXMgdGhpcyBtYXRyaXggcG9zdFxuICAgKiBtdWx0aXBsaWVkIGJ5IGEgdHJhbnNsYXRpb24gbWF0cml4IGNvbnRhaW5pbmcgdGhlIHBhc3NlZCB2YWx1ZXMuIElmIHRoZSB6XG4gICAqIGNvbXBvbmVudCBpcyB1bmRlZmluZWQsIGEgMCB2YWx1ZSBpcyB1c2VkIGluIGl0cyBwbGFjZS4gVGhpcyBtYXRyaXggaXMgbm90XG4gICAqIG1vZGlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0geCBYIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNsYXRpb24gdmFsdWUuXG4gICAqIEBwYXJhbSB5IFkgY29tcG9uZW50IG9mIHRoZSB0cmFuc2xhdGlvbiB2YWx1ZS5cbiAgICogQHBhcmFtIHogWiBjb21wb25lbnQgb2YgdGhlIHRyYW5zbGF0aW9uIHZhbHVlLlxuICAgKiBAcmV0dXJuIFRoZSByZXN1bHRlZCBtYXRyaXhcbiAgICovXG4gIHRyYW5zbGF0ZSh0LCBlLCBuKSB7XG4gICAgY29uc3QgaSA9IHQ7XG4gICAgbGV0IHIgPSBlLCBhID0gbjtcbiAgICByZXR1cm4gdHlwZW9mIHIgPiBcInVcIiAmJiAociA9IDApLCB0eXBlb2YgYSA+IFwidVwiICYmIChhID0gMCksIE4odGhpcywgWShpLCByLCBhKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsZSBtZXRob2QgcmV0dXJucyBhIG5ldyBtYXRyaXggd2hpY2ggaXMgdGhpcyBtYXRyaXggcG9zdCBtdWx0aXBsaWVkIGJ5XG4gICAqIGEgc2NhbGUgbWF0cml4IGNvbnRhaW5pbmcgdGhlIHBhc3NlZCB2YWx1ZXMuIElmIHRoZSB6IGNvbXBvbmVudCBpcyB1bmRlZmluZWQsXG4gICAqIGEgMSB2YWx1ZSBpcyB1c2VkIGluIGl0cyBwbGFjZS4gSWYgdGhlIHkgY29tcG9uZW50IGlzIHVuZGVmaW5lZCwgdGhlIHhcbiAgICogY29tcG9uZW50IHZhbHVlIGlzIHVzZWQgaW4gaXRzIHBsYWNlLiBUaGlzIG1hdHJpeCBpcyBub3QgbW9kaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB4IFRoZSBYIGNvbXBvbmVudCBvZiB0aGUgc2NhbGUgdmFsdWUuXG4gICAqIEBwYXJhbSB5IFRoZSBZIGNvbXBvbmVudCBvZiB0aGUgc2NhbGUgdmFsdWUuXG4gICAqIEBwYXJhbSB6IFRoZSBaIGNvbXBvbmVudCBvZiB0aGUgc2NhbGUgdmFsdWUuXG4gICAqIEByZXR1cm4gVGhlIHJlc3VsdGVkIG1hdHJpeFxuICAgKi9cbiAgc2NhbGUodCwgZSwgbikge1xuICAgIGNvbnN0IGkgPSB0O1xuICAgIGxldCByID0gZSwgYSA9IG47XG4gICAgcmV0dXJuIHR5cGVvZiByID4gXCJ1XCIgJiYgKHIgPSB0KSwgdHlwZW9mIGEgPiBcInVcIiAmJiAoYSA9IDEpLCBOKHRoaXMsIEkoaSwgciwgYSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRlIG1ldGhvZCByZXR1cm5zIGEgbmV3IG1hdHJpeCB3aGljaCBpcyB0aGlzIG1hdHJpeCBwb3N0IG11bHRpcGxpZWRcbiAgICogYnkgZWFjaCBvZiAzIHJvdGF0aW9uIG1hdHJpY2VzIGFib3V0IHRoZSBtYWpvciBheGVzLCBmaXJzdCBYLCB0aGVuIFksIHRoZW4gWi5cbiAgICogSWYgdGhlIHkgYW5kIHogY29tcG9uZW50cyBhcmUgdW5kZWZpbmVkLCB0aGUgeCB2YWx1ZSBpcyB1c2VkIHRvIHJvdGF0ZSB0aGVcbiAgICogb2JqZWN0IGFib3V0IHRoZSB6IGF4aXMsIGFzIHRob3VnaCB0aGUgdmVjdG9yICgwLDAseCkgd2VyZSBwYXNzZWQuIEFsbFxuICAgKiByb3RhdGlvbiB2YWx1ZXMgYXJlIGluIGRlZ3JlZXMuIFRoaXMgbWF0cml4IGlzIG5vdCBtb2RpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHJ4IFRoZSBYIGNvbXBvbmVudCBvZiB0aGUgcm90YXRpb24sIG9yIFogaWYgWSBhbmQgWiBhcmUgbnVsbC5cbiAgICogQHBhcmFtIHJ5IFRoZSAob3B0aW9uYWwpIFkgY29tcG9uZW50IG9mIHRoZSByb3RhdGlvbiB2YWx1ZS5cbiAgICogQHBhcmFtIHJ6IFRoZSAob3B0aW9uYWwpIFogY29tcG9uZW50IG9mIHRoZSByb3RhdGlvbiB2YWx1ZS5cbiAgICogQHJldHVybiBUaGUgcmVzdWx0ZWQgbWF0cml4XG4gICAqL1xuICByb3RhdGUodCwgZSwgbikge1xuICAgIGxldCBpID0gdCwgciA9IGUgfHwgMCwgYSA9IG4gfHwgMDtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZSA+IFwidVwiICYmIHR5cGVvZiBuID4gXCJ1XCIgJiYgKGEgPSBpLCBpID0gMCwgciA9IDApLCBOKHRoaXMsIEYoaSwgciwgYSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm90YXRlQXhpc0FuZ2xlIG1ldGhvZCByZXR1cm5zIGEgbmV3IG1hdHJpeCB3aGljaCBpcyB0aGlzIG1hdHJpeCBwb3N0XG4gICAqIG11bHRpcGxpZWQgYnkgYSByb3RhdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYXhpcyBhbmQgYGFuZ2xlYC4gVGhlIHJpZ2h0LWhhbmRcbiAgICogcnVsZSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHJvdGF0aW9uLiBBbGwgcm90YXRpb24gdmFsdWVzIGFyZVxuICAgKiBpbiBkZWdyZWVzLiBUaGlzIG1hdHJpeCBpcyBub3QgbW9kaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB4IFRoZSBYIGNvbXBvbmVudCBvZiB0aGUgYXhpcyB2ZWN0b3IuXG4gICAqIEBwYXJhbSB5IFRoZSBZIGNvbXBvbmVudCBvZiB0aGUgYXhpcyB2ZWN0b3IuXG4gICAqIEBwYXJhbSB6IFRoZSBaIGNvbXBvbmVudCBvZiB0aGUgYXhpcyB2ZWN0b3IuXG4gICAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gYWJvdXQgdGhlIGF4aXMgdmVjdG9yLCBpbiBkZWdyZWVzLlxuICAgKiBAcmV0dXJuIFRoZSByZXN1bHRlZCBtYXRyaXhcbiAgICovXG4gIHJvdGF0ZUF4aXNBbmdsZSh0LCBlLCBuLCBpKSB7XG4gICAgaWYgKFt0LCBlLCBuLCBpXS5zb21lKChyKSA9PiBOdW1iZXIuaXNOYU4oK3IpKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDU1NNYXRyaXg6IGV4cGVjdGluZyA0IHZhbHVlc1wiKTtcbiAgICByZXR1cm4gTih0aGlzLCBUKHQsIGUsIG4sIGkpKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWVzIGEgc2tldyB0cmFuc2Zvcm1hdGlvbiBhbG9uZyB0aGUgYHgtYXhpc2AgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgKiBUaGlzIG1hdHJpeCBpcyBub3QgbW9kaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgYW1vdW50IGluIGRlZ3JlZXMgdG8gc2tldy5cbiAgICogQHJldHVybiBUaGUgcmVzdWx0ZWQgbWF0cml4XG4gICAqL1xuICBza2V3WCh0KSB7XG4gICAgcmV0dXJuIE4odGhpcywgUih0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBhIHNrZXcgdHJhbnNmb3JtYXRpb24gYWxvbmcgdGhlIGB5LWF4aXNgIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICogVGhpcyBtYXRyaXggaXMgbm90IG1vZGlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIGFtb3VudCBpbiBkZWdyZWVzIHRvIHNrZXcuXG4gICAqIEByZXR1cm4gVGhlIHJlc3VsdGVkIG1hdHJpeFxuICAgKi9cbiAgc2tld1kodCkge1xuICAgIHJldHVybiBOKHRoaXMsIEQodCkpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgYSBza2V3IHRyYW5zZm9ybWF0aW9uIGFsb25nIGJvdGggdGhlIGB4LWF4aXNgIGFuZCBgeS1heGlzYC5cbiAgICogVGhpcyBtYXRyaXggaXMgbm90IG1vZGlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0gYW5nbGVYIFRoZSBYLWFuZ2xlIGFtb3VudCBpbiBkZWdyZWVzIHRvIHNrZXcuXG4gICAqIEBwYXJhbSBhbmdsZVkgVGhlIGFuZ2xlIGFtb3VudCBpbiBkZWdyZWVzIHRvIHNrZXcuXG4gICAqIEByZXR1cm4gVGhlIHJlc3VsdGVkIG1hdHJpeFxuICAgKi9cbiAgc2tldyh0LCBlKSB7XG4gICAgcmV0dXJuIE4odGhpcywgdih0LCBlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSBzcGVjaWZpZWQgdmVjdG9yIHVzaW5nIHRoZSBtYXRyaXgsIHJldHVybmluZyBhIG5ld1xuICAgKiB7eCx5LHosd30gVHVwbGUgKk9iamVjdCogY29tcHJpc2luZyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yLlxuICAgKiBOZWl0aGVyIHRoZSBtYXRyaXggbm9yIHRoZSBvcmlnaW5hbCB2ZWN0b3IgYXJlIGFsdGVyZWQuXG4gICAqXG4gICAqIFRoZSBtZXRob2QgaXMgZXF1aXZhbGVudCB3aXRoIGB0cmFuc2Zvcm1Qb2ludCgpYCBtZXRob2RcbiAgICogb2YgdGhlIGBET01NYXRyaXhgIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gdCBUdXBsZSB3aXRoIGB7eCx5LHosd31gIGNvbXBvbmVudHNcbiAgICogQHJldHVybiB0aGUgcmVzdWx0aW5nIFR1cGxlXG4gICAqL1xuICB0cmFuc2Zvcm1Qb2ludCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMubTExICogdC54ICsgdGhpcy5tMjEgKiB0LnkgKyB0aGlzLm0zMSAqIHQueiArIHRoaXMubTQxICogdC53LCBuID0gdGhpcy5tMTIgKiB0LnggKyB0aGlzLm0yMiAqIHQueSArIHRoaXMubTMyICogdC56ICsgdGhpcy5tNDIgKiB0LncsIGkgPSB0aGlzLm0xMyAqIHQueCArIHRoaXMubTIzICogdC55ICsgdGhpcy5tMzMgKiB0LnogKyB0aGlzLm00MyAqIHQudywgciA9IHRoaXMubTE0ICogdC54ICsgdGhpcy5tMjQgKiB0LnkgKyB0aGlzLm0zNCAqIHQueiArIHRoaXMubTQ0ICogdC53O1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgRE9NUG9pbnQgPyBuZXcgRE9NUG9pbnQoZSwgbiwgaSwgcikgOiB7XG4gICAgICB4OiBlLFxuICAgICAgeTogbixcbiAgICAgIHo6IGksXG4gICAgICB3OiByXG4gICAgfTtcbiAgfVxufVxucCh5LCBcIlRyYW5zbGF0ZVwiLCBZKSwgcCh5LCBcIlJvdGF0ZVwiLCBGKSwgcCh5LCBcIlJvdGF0ZUF4aXNBbmdsZVwiLCBUKSwgcCh5LCBcIlNjYWxlXCIsIEkpLCBwKHksIFwiU2tld1hcIiwgUiksIHAoeSwgXCJTa2V3WVwiLCBEKSwgcCh5LCBcIlNrZXdcIiwgdiksIHAoeSwgXCJNdWx0aXBseVwiLCBOKSwgcCh5LCBcImZyb21BcnJheVwiLCBnKSwgcCh5LCBcImZyb21NYXRyaXhcIiwgWCksIHAoeSwgXCJmcm9tU3RyaW5nXCIsIE8pLCBwKHksIFwidG9BcnJheVwiLCB4KSwgcCh5LCBcImlzQ29tcGF0aWJsZUFycmF5XCIsIEUpLCBwKHksIFwiaXNDb21wYXRpYmxlT2JqZWN0XCIsIFApO1xuZXhwb3J0IHtcbiAgeSBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tbWF0cml4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@thednp/dommatrix/dist/dommatrix.mjs\n");

/***/ })

};
;